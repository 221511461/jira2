// Original source code:
// https://bitbucket.org/atlassian/atlassian-connect-express/src/f434e5a9379a41213acf53b9c2689ce5eec55e21/lib/middleware/authentication.js?at=master&fileviewer=file-view-default#authentication.js-227
// TODO: need some typing for jwt
import { createQueryStringHash, decodeAsymmetric, decodeSymmetric, getAlgorithm, getKeyId } from "atlassian-jwt";
import { NextFunction, Request, Response } from "express";
import { envVars } from "config/env";
import { queryAtlassianConnectPublicKey } from "./query-atlassian-connect-public-key";
import { includes, isEmpty } from "lodash";

const JWT_PARAM = "jwt";
const AUTH_HEADER = "authorization"; // the header name appears as lower-case
const BASE_URL = envVars.APP_URL;

/**
 * Atlassian Connect has 2 different types of JWT tokens.
 * Normal tokens has qsh parameter and generated by Jira for backend authentication (like installation webhooks)
 * or web elements like iFrame
 *
 * Context tokens are tokens which are generated by App iframes for the authentication with app backend.
 * They don't require sqh verification and their qsh is set to a fixed `context-qsh` value.
 *
 * When building endpoints we should specify which type of tokens they require
 *
 * See details at: https://community.developer.atlassian.com/t/action-required-atlassian-connect-vulnerability-allows-bypass-of-app-qsh-verification-via-context-jwts/47072
 */
export enum TokenType {
	normal = "normal",
	context = "context"
}


const extractJwtFromRequest = (req: Request): string | undefined => {

	const tokenInQuery = req.query?.[JWT_PARAM];
	const tokenInBody = req.body?.[JWT_PARAM];
	if (tokenInQuery && tokenInBody) {
		req.log.info("JWT token can only appear in either query parameter or request body.");
		return;
	}
	let token = tokenInQuery || tokenInBody;

	const authHeader = req.headers?.[AUTH_HEADER];
	if (authHeader?.startsWith("JWT ")) {
		if (token) {
			const foundIn = tokenInQuery ? "query" : "request body";
			req.log.info(`JWT token found in ${foundIn} and in header: using ${foundIn} value.`);
		} else {
			token = authHeader.substring(4);
		}
	}

	if (!token) {
		token = req.cookies?.[JWT_PARAM];
		if (token) {
			req.log.info("JWT token found in cookies (last resort)");
		}
	}

	// JWT is missing in query and we don't have a valid body.
	if (!token) {
		req.log.info("JWT token is missing in the request");
	}

	return token;
};

export const sendError = (res: Response, code: number, msg: string): void => {
	res.status(code).json({
		message: msg
	});
};

//disable eslint rule as decodeAsymmetric return any
/*eslint-disable @typescript-eslint/no-explicit-any*/
const decodeAsymmetricToken = (token: string, publicKey: string, noVerify: boolean): any => {
	return decodeAsymmetric(
		token,
		publicKey,
		getAlgorithm(token),
		noVerify
	);
};

export const validateQsh = (tokenType: TokenType, qsh: string, fullUrl: string): boolean => {
	// If token type if of type context, verify automatically if QSH is the correct string
	if (tokenType === TokenType.context && qsh === "context-qsh") {
		return true;
	}

	// to get full path from express request, we need to add baseUrl with path
	/**
	 * TODO: Remove `decodeURIComponent` later
	 * This has been added here as a temporarily until the `qsh` bug is fixed
	 *
	 * Bug: This method `createQueryStringHash` doesn't handle the decoded URI strings passed along the path
	 * For e.g. If we pass a string `http%3A%2F%2Fabc.com`, it doesn't encode it to `http://abc.com`,
	 * but uses the original string, which returns a different `qsh` value.
	 * Because of this reason, if we have any decoded URI in the request path, then it always fails with an error `Wrong qsh`
	 */
	const requestInAtlassianJwtFormat = { ...req, pathname: req.baseUrl + decodeURIComponent(req.path) };
	let expectedHash = createQueryStringHash(requestInAtlassianJwtFormat, false, BASE_URL);
	const signatureHashVerified = qsh === expectedHash;

	if (!signatureHashVerified) {
		// If that didn't verify, it might be a post/put - check the request body too
		expectedHash = createQueryStringHash(requestInAtlassianJwtFormat, true, BASE_URL);
		return qsh === expectedHash;
	}
	return true;
};

export const validateJwtClaims = (verifiedClaims: { exp: number, qsh: string | undefined }, tokenType: TokenType, fullUrl: string): void => {
	if (!verifiedClaims.qsh) {
		throw "JWT validation Failed, no qsh";
	}

	// 3 second leeway in case of time drift
	if (verifiedClaims.exp && (Date.now() / 1000 - 3) >= verifiedClaims.exp) {
		throw "JWT validation failed, token is expired";
	}

	if (!validateQsh(tokenType, verifiedClaims.qsh, fullUrl)) {
		throw "JWT Verification Failed, wrong qsh";
	}
};

const validateSymmetricJwt = (secret: string, fullUrl:string, tokenType: TokenType, token?: string): void => {
	if (!token) {
		throw "Could not find authentication data on request";
	}

	const algorithm = getAlgorithm(token);

	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	let unverifiedClaims: any;
	try {
		unverifiedClaims = decodeSymmetric(token, "", algorithm, true); // decode without verification;
	} catch (e) {
		throw `Invalid JWT: ${e.message}`;
	}

	if (!unverifiedClaims.iss) {
		throw "JWT claim did not contain the issuer (iss) claim";
	}

	/* eslint-disable @typescript-eslint/no-explicit-any*/
	let verifiedClaims: any; //due to decodeSymmetric return any
	try {
		verifiedClaims = decodeSymmetric(token, secret, algorithm, false);
	} catch (error) {
		throw `Unable to decode JWT token: ${error}`;
	}

	validateJwtClaims(verifiedClaims, tokenType, fullUrl);
};

/**
 * Middleware function which verifies JWT token signed by symmetric shared key
 *
 * @param secret Shared key
 * @param tokenType Type of the token normal or context. Context tokens have different qsh verification behaviour
 * @param req Request
 * @param res Response
 * @param next Next function
 */
export const verifySymmetricJwtTokenMiddleware = (secret: string, tokenType: TokenType, req: Request, res: Response, next: NextFunction): void => {
	try {
		const token = extractJwtFromRequest(req);
		validateSymmetricJwt(secret, getFullUrl(req), tokenType, token);
		req.log.info("JWT Token Verified Successfully!");
		next();
	} catch (error) {
		req.log.error(error, "Error happened when validating JWT token");
		sendError(res, 401, "Unauthorized");
		return;
	}
};

const ALLOWED_BASE_URLS = [BASE_URL];

const isStagingTenant = (req: Request): boolean => {
	try {
		const hostBaseUrl = req.body?.baseUrl;
		if (hostBaseUrl) {
			const host = new URL(hostBaseUrl).hostname;
			return /\.jira-dev\.com$/.test(host);
		}
	} catch (err) {
		req.log.error(err, "Error determining Jira instance environment");
	}
	return false;
};

export const validateAsymmetricJwtTokenMiddleware = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
	try {
		const token = extractJwtFromRequest(req);
		await validateAsymmetricJwtToken(getFullUrl(req), token, isStagingTenant(req));
		req.log.info("JWT Token Verified Successfully!");
		next();
	} catch (err) {
		req.log.info(err, "Could not validate JWT token");
		res.status(401).json({
			message: "Unauthorized"
		});
	}
};

export const validateAsymmetricJwtToken = async (fullUrl: string, token?: string, isStaginTenant = false) => {

	if (!token) {
		throw "JWT Verification Failed, no token present";
	}

	const publicKey = await queryAtlassianConnectPublicKey(getKeyId(token), isStaginTenant);
	const unverifiedClaims = decodeAsymmetricToken(token, publicKey, true);

	const issuer = unverifiedClaims.iss;
	if (!issuer) {
		throw "JWT claim did not contain the issuer (iss) claim";
	}

	if (isEmpty(unverifiedClaims.aud) ||
		!unverifiedClaims.aud[0] ||
		!includes(ALLOWED_BASE_URLS, unverifiedClaims.aud[0].replace(/\/$/, ""))) {
		throw "JWT claim did not contain the correct audience (aud) claim";
	}

	const verifiedClaims = decodeAsymmetricToken(token, publicKey, false);

	validateJwtClaims(verifiedClaims, TokenType.normal, fullUrl);
};

const getFullUrl = (req: Request) => `${req.protocol}://${req.get("host")}${req.originalUrl}`;
